/* Ch13. 정렬 */

/*
  만약 구슬들을 크기 별로 나열해야 한다면 ?
  크기별, 일단 분류해서 정리 이런 행동들을 '정렬' 이고 부른다.

  * 정렬 *
  요소들을 일정한 순서대로 열거하는 알고리즘

  * 정렬의 특징 *
  - 정렬 기준은 사용자가 정할 수 있다. (무슨 값을 기준으로 할지, 오름차순, 내림차순)
  - 크게 비교식과 분삭식 정렬으로 나눌 수 있다.
  - 대부분의 언어가 빌트인으로 제공해준다.
  - 삽입, 선택, 버블, 머지, 힙, 퀵 정렬 등 다양한 정렬 방식이 존재한다.

  * 어떤 정렬이 제일 빠를까? *
  각각 유리한 상황, 불리한 상황이 있기 때문에 무엇이 좋고 나쁨이 정해져있지 않다.
  https://www.toptal.com/developers/sorting-algorithms
  이 사이트에서 확인해볼 수 있다.

  *** 비교식 정렬 ***
  다른 요소와 비교를 통해 정렬하는 방식

  - 버블 정렬
    ㄴ 서로 인접한 두 요소를 검사하여 정렬하는 알고리즘
      O(n의 제곱) 시간 복잡도를 가진다.
    
    버블 정렬이 이루어지는 방식
    * 첫 번째 순회
    1 - [7, 4, 5, 1, 3] => 정렬되지 않은 배열에서 첫번째요소에서 인접한 요소를 검사, 7보다 4가 작기 때문에 교환
    2 - [4, 7, 5, 1, 3] => 교환 후 두 번째 요소, 세 번째 요소를 교환한다
    3 - [4, 5, 7, 1, 3] => 세 번째 요소와 네 번째 요소를 비교하고 7보다 1이 작기 때문에 교환한다
    4 - [4, 5, 1, 7, 3] => 마지막으로 네 번째와 다섯 번째를 교환한 후 3이 7보다 작으니 바꾼다
    5 - [4, 5, 1, 3, 7]

    * 두 번째 순회
    1 - [4, 5, 1, 3, 7] => 첫 번째 요소와 두 번째 요소를 비교 4가 5보다 작기 때문에 교환하지 않음
    2 - ... 이런 순서로 마지막까지 간다
    [4, 1, 3, 5, 7]

    * 세 번째 순회
    1 - [4, 1, 3, 5, 7] => 1이 더 작기 때문에 4와 1을 교환
    2 - 마지막까지 순회
    [1, 3, 4, 5, 7]

    * 네 번째 순회
    [1, 3, 4, 5, 7] => 1과 3을 비교한다음에 교환하지 않고 마무리 된다
    
    **** 결국 버블 정렬은 n-1번 순회하면 정렬이 마무리 된다 ****

  - 선택 정렬
    ㄴ 선택한 요소와 가장 우선순위가 높은 요소를 교환하는 정렬 알고리즘
      O(n의 제곱) 시간 복잡도를 가진다.

    1 - [7, 4, 5, 1, 3] => 선택된 첫번째 요소와 나머지 요소중 가장 우선순위가 높은 1과 교환
    2 - [1, 4, 5, 7, 3] => 두 번째 요소와 나머지 요소중 가장 우선순위가 높은 3과 교환 (이렇게되면 앞의 1, 3은 정렬이 됨)
    3 - [1, 3, 5, 7, 4] => 같은 맥락으로 5와 나머지 요소중 우선순위가 높은 4와 교환
    4 - [1, 3, 4, 7, 5] => 마지막으로 남은 요소를 비교한 후 교환한다.
    [1, 3, 4, 5, 7] 

  - 삽입 정렬

    ㄴ 선택한 요소를 삽입할 수 있는 위치를 찾아 삽입하는 방식의 정렬 알고리즘
      O(n의 제곱) 시간 복잡도를 가진다.

    1 - [7, 4, 5, 1, 3] => 삽입정렬은 두 번째 요소부터 시작한다 4를 선택하여 7과 비교. 7이 더 크기때문에 7을 밀어내고 4가 삽입

    2-1 - [4, 7, 5, 1, 3] => 5와 7을 비교해서 7을 밀어낸다. 
    2-2 - [4, 5, 7, 1, 3] => 5가 4와 비교하는데 4가 더 작으니 밀어내지 못하고 그대로 5에 삽입되고 종료

    3-1 - [4, 5, 7, 1, 3] => 4번째요소인 1을 선택해서 7, 5, 4 순서대로 미는게 가능해서 1이 맨 앞으로 오게된다

    4-1 - [1, 4, 5, 7, 3] => 마지막 요소인 3도 마찬가지로 쭉 밀어내면서 오고 1과 비교했을때 밀어낼 수 없으므로 2번째에 삽입이 된다.

    **** 복잡하지만 어느정도 정렬이 되어있다는 가정하에서는 퀵 정렬보다 빠르다.

  *** 분산식 정렬 ***
  요소를 분산하여 정렬하는 방식을 뜻함

  * 분할 정복 *
  분산식 정렬에 쓰이는 핵심적인 전략.
  문제를 작은 2개의 문제로 분리하고 더 이상 분리가 불가능 할 때 처리한 후 합치는 전략.
  다양한 알고리즘에 응용된다.

  - 합병 정렬
    ㄴ 분할 정복 알고리즘을 이용한 최선과 최악이 같은 안정적인 정렬 알고리즘
    O(n log n) 시간 복잡도를 가진다

  * Divide *
  우선 요소를 절반으로 나눈다.
  21 10 12 20 25 13 15 22
  21 10 12 20 | 25 13 15 22 우선 절반으로 나눔
  21 10 | 12 20 | 25 13 | 15 22 
  21 | 10 | 12 | 20 | 25 | 13 | 15 | 22
  요소가 하나만 남을때까지 계속해서 절반으로 나눈다

  * Conquer *
  모든 요소를 나누었다면 합치는 알고리즘이 진행된다.
  나눈 것을 합치면 두 요소중 작은것을 먼저 배치한다.
  21 | 10 | 12 | 20 | 13 | 25 | 15 | 22
  21과 10의 경우 10이 먼저 배치되고 21이 배치된다. 이어서 2개짜리를 합칠때도 작은순으로 배치한다
  이 작업들은 선형시간이 소요된다.
  10 21 | 12 20 | 13 25 | 15 22
  10 12 20 21 | 13 15 22 25
  10 12 13 15 20 21 22 25 
  최종적으로 나머지를 전부 합치면 정렬된 상태가 된다
  선형시간이 n log n만큼 시간 복잡도가 소요된다.

  - 퀵 정렬
    ㄴ 분할 정복 알고리즘을 이용한 매우 빠르지만 최악의 경우가 존재하는 불안정 정렬(그래서 불안정 정렬이라고도 부른다)
      O(n log n) 시간복잡도를 가진다.

  피벗이라는 기준으로 좌측과 우측을 나눈다 
  1 - 5, 3, 8, 4, 9, 1, 6, 2, 7
     예를들어 5를 피벗으로 잡게된다면 5를 기준으로 작은값을 왼쪽에 배치, 큰 값을 오른쪽에 배치한다

  2 - 1, 3, 2, 4, 5, 9, 6, 8, 7
      다시 나뉜 배열에서 첫번째 요소가 피벗이 된다. 각각 1과 9가 피벗이 된다.
  
  3 - 1, 3, 2, 4, | 5, | 7 6, 8, 9
      1과 9를 기준으로 나뉜다. 

  4 - 1 | 2 3 4 | 5 | 6 7 8 | 9
      마지막으로 더이상 나눌 수 없는 경우가 되면 합쳐지는데 그럼 정렬이 된다.


  *** JAVASCRIPT

  sort함수를 사용하면 되는데 그냥 정렬함수를 이용할 경우 ASCII 문자 순서로 되기 때문에
  원하는 대로 나오지 않을 수 있으니 정렬의 기준을 만들어주는 함수를 같이 전달해주어야한다.
*/

/* ------ JavaScript에서의 사용법 ------ */

const array = [5, 9, 10, 3, 8, 3, 2];
// 다음과 같이 그냥 정렬하면 ASCII 문자 순서로 정렬되어
// 우리가 원하는 숫자 크기대로 정렬이 되지 않는다.

array.sort()
console.log(array); // 10, 2, 3, 3, 5, 8, 9
// 10이 먼저 나오는 이유는 ASCII 문자 '1'이 '2'보다 작기 때문

array.sort((a, b) => a - b); // 오름차순 정렬
console.log(array); // 2, 3, 3, 5, 8, 9, 10

array.sort((a, b) => b - a); // 내림차순 정렬
console.log(array); // 10, 9, 8, 5, 3, 3, 2
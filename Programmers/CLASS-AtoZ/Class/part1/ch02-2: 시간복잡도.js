/* Ch02-2. 시간복잡도 */

/*
  프로그램의 성능을 알려면 
  입력크기 , 하드웨어 성능, 운영체제 성능, 컴파일러 최적화, 비동기 로직 등을 고려해보아야 할것이다

  실행환경과 메모리등의 따라 다르기 때문에
  성능을 정확히 파악하는것은 불가능하다. 그래서 상대적인 표기법을 사용하기로 했다

  *** Big-O notation ***
  Big-O에 쓰인 n의 값이 같다고 할 때 이 순서대로 느려진다
  O(1) < O(log n) < O(n) < O(n log n) < O(n의2승) < O(2의n승) < O(n!)
  상수시간 < 로그시간 < 선형시간 < 선형로그시간 < 2차시간 < 지수시간 < 팩토리얼시간

  참고로 log는 밑이 2이다. 컴퓨터과학에서 밑을 생략하면 기본적으로 2 이다


  * 빅오 표기법에는 왜 식의 계수가 있거나 상수를 더하고 빼는것이 없을까?

  빅오 표기법은 '점근적 표기법'을 따르기 때문이다.
  점근적 표기법은 함수의 증감추세를 비교하는 방법이다


  ** 계수 법칙
  상수 k가 0보다 클 때 f(n) = O(g(n))이면 kf(n) = O(g(n))이다.
  * n이 무한에 가까울 수록 k의 크기는 의미가 없기 때문이다 *

  ** 합의 법칙 
  f(n) = O(h(n))이고 g(n) = O(p(n))이면 f(n) + g(n) = O(h(n)) + O(p(n))이다
  빅오는 더해질 수 있다

  ** 곱의 법칙
  f(n) = O(h(n))이고 g(n) = O(p(n))이면 f(n) * g(n) = O(h(n)) * O(p(n))이다
  빅오는 곱해질 수 있다

  ** 다항 법칙
  f(n)이 k차 다항식이면 f(n)은 O(n의k승)이다


  ****** 기억할 2가지 ******
  1. 상수항은 무시
  계수법칙에 의해 계수는 무시된다 그리하여 O(n + m)으로 표기된다
  for (let i = 0; i < n * 6; i += 1) {
    // ...
  }
  
  for (let i = 0; i < m * 3; i += 1) {[
    // ...
  ]}

  2. 가장 큰 항 외엔 무시
  O(n^2 + n)이지만 작은 항은 무시하여 O(n^2)으로만 표기해도 된다
  for (let i = 0; i < n; i += 1) {
    // ...
  }

  for (let i = 0; i < n; i += 1) {
    for (let j = 0; j < n; j += 1) {
      // ...
    }
  }

  * 성능 측정 방법

  자바스크립트에서 성능 측정할때 많은 방법들이 있지만
  오래된 브라우저에서도 사용가능하고 간단하게 사용하기 위해
  Date 객체를 이용

*/

// ** O(n) 입력받은 크기만큼 loop
for (let i = 0; i < n ; i += 1) {
  // ...
}

// **  O(log n) 입력받은 n에 log를 씌운만큼만 log
for (let i = 1; i <= n; i *= 2) {
  // ...
}

// *** O(n log n) 선형시간에 지수시간을 곱한것
for (let i = 0; i < n; i += 1) {
  for (let j = 1; j <= n; j *= 2) {
    // ...
  }
}

// *** O(n의2승) n의 제곱만큼만 loop
for (let i = 0; i < n; i += 1) {
  for (let j = 0; j < n; j += 1) {
    // ...
  }
}

// ***** 지수시간이나 팩토리얼시간은 특정한상황이 아니라면 가급적 사용하면 안된다. 거의 코테에서는 n의3승이상은 사용이안된다

// 계수 법칙

//두 루프는 같은 O(n)으로 표기된다
for (let i = 0; i < n; i += 1) {
  // ...
}
for (let i = 0; i < n * 5; i += 1) {
  // ...
}

// 합의법칙

// 두 루프를 합쳐 O(n + m)으로 표기할 수 있다
// 계수 법칙에 의해 5는 사라진다
for (let i = 0; i < n; i += 1) {
  // ...
}

for (let i = 0; i < m * 5; i += 1) {
  // ...
}

// 곱의 법칙

// 두 루프를 곱해 (On^2)으로 표기할 수 있다.
// 계수 법칙에 의해 5는 사라진다
for (let i = 0; i < n; i += 1) {
  for (let j = 0; j < n * 5; j += 1) {
    // ...
  }
}

// 다항 법칙

// 다음 루프는 O(n^3)으로 표기할 수 있다
for (let i = 0; i < n * n * n; i += 1) {
  // ...
}

// 성능 측정 방법

const start = new Date().getTime();

// ... 

const end = new Date().getTime();
console.log(end - start);
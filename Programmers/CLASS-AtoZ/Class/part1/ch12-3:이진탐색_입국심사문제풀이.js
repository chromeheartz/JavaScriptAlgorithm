/* Ch12-3. 이진 탐색_입국 심사 실습 문제 풀이 */

/*
  * 문제 설명 *

  n명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 
  각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다.
  처음에 모든 심사대는 비어있습니다. 
  한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. 
  가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. 
  하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다.

  모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다.
  입국심사를 기다리는 사람 수 n, 각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 times가 매개변수로 주어질 때, 
  모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return 하도록 solution 함수를 작성해주세요.

  * 제한사항 *

  - 입국심사를 기다리는 사람은 1명 이상 1,000,000,000명 이하입니다.
  - 각 심사관이 한 명을 심사하는데 걸리는 시간은 1분 이상 1,000,000,000분 이하입니다.
  - 심사관은 1명 이상 100,000명 이하입니다.

  * 문제 풀이 *
  모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다.

  이 부분이 핵심이 되는 부분이다 '최소'
  제한사항을 보면 사람이나 시간으로 기준을 잡아 loop를 돌리게 되면 너무 크기 때문에
  심사관을 기준으로 하는것이 좋을것이다.

  시간을 1분씩 증가시키면서 심사관을 탐색해볼 수 있겠지만 시간의 최대가 너무 크기 때문에 
  불가능한 로직이 될것이다.

  이정도로 숫자가 크다면 정답유형은 1개밖에 없다.
  10억명이면 선형식 탐색이 불가능하기 때문에 '로그 시간' 알고리즘인 '이진 탐색'을 사용해야 한다.
  이진 탐색을 위해서 정렬이 필요하지만 times가 10만 이하이기 떄문에 '선형 로그 시간'으로도 충분히 가능

  ** 포인트
  - 특정 값을 찾는 것이 아니다.
  - 최소 몇 분에 모든 심사가 끝나는가
    ㄴ 어떤 값을 찾는것이 아니라 조건에 맞는 값을 찾는것을 '결정' 문제라고 부른다.
    ㄴ '결정 문제'를 해결할때 쓰는 알고리즘을 '이진 탐색' 이라고 불렀지만 '파라매트리 서치(Parametric Search)' 라고도 부른다.

  ** 전략
  - 이진 탐색이니 최소 1분에서 10억분 * n명 사이에 값이 있다는 것은 확실.
  - 면접관들이 몇 명을 처리하는가?
  - 처리 가능한 입국자가 n보다 작다면 분을 올려야하고, n보다 크다면 분을 낮춰야한다.
  - 면접관이 시간대비 몇 명을 처리할 수 있는가? (시간 / 심사시간 = 심사관 당 처리가능한 입국자 수)

  ** 함수 작성

  1. 심사하는데 걸리는 시간을 이진 탐색을 이용하기 위해 정렬 (오름차순)
    const sortedTimes = times.sort((a, b) => a - b); // O(n log n)

  2. 이진탐색을 해주기 위해 left, right를 정해줌
    let left = 1; (한명을 심사하는데 걸리는 시간은 최소 1분)
    let right = sortedTimes[sortedTimes.length - 1] * n; (정렬된 시간의 가장 마지막 * n)
    ㄴ 10억분을 넣어도 되지만 제일 느린 면접관이 모든것을 처리한다 가 최악이 됨

  3. 이진탐색 loop
    while (left <= right) {  (left가 right와 같거나 작다면 loop)
      const mid = Math.floor((left + right) / 2); (중간값 구하기. 내림을 하는 이유는 소수점이 나오면 안되기 때문)

      // (시간 / 심사시간) 으로 입국자수를 구하는데 모든 값을 더해야한다.
      // 심사관들이 각각 몇명을 처리할 수 있는지 고차함수로 풀이
      const sum = times.reduce((acc, time) => acc + Math.floor(mid / time), 0);

      // 만약 n보다 작다면 시간을 늘려주고
      // n보다 크다면 시간을 줄여야한다.

      if (sum < n) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    } 
    
    4. 결국엔 최소한 범위를 좁혀서 left가 right를 넘어서는 순간이 있는데 
       이 때 반환은 역전되기 직전에서 더해진 값을 반환하면 된다
    return left;
*/


function solution(n, times) {
  const sortedTimes = times.sort((a, b) => a - b); // O(n log n)
  let left = 1;
  let right = sortedTimes[sortedTimes.length - 1] * n;

  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    // sum([시간 / 심사시간])
    const sum = times.reduce((acc, time) => acc + Math.floor(mid / time), 0);

    if (sum < n) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return left;
}
/* Ch14-3. BFS,DFS_가장 먼 노드 문제 풀이 */

/*
  * 문제 설명 *

  어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다.

  예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 
  이 중 가장 큰 숫자는 94 입니다.

  문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다.
  number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 
  return 하도록 solution 함수를 완성하세요.

  * 제한사항 *

  - number는 2자리 이상, 1,000,000자리 이하인 숫자입니다.
  - k는 1 이상 number의 자릿수 미만인 자연수입니다.

  * 문제 풀이 *

  숫자 리스트에서 k개를 제거한 후 가장 큰 수가 이 문제의 핵심
  모든 경우의수에서 그 중 가장 큰 것을 찾는다 라고 볼 수도 있지만
  제한 조건에서 자리수가 크기 때문에 시간복잡도가 너무 크니 효율성테슽트에서 걸릴 확률이 높다.

  입출력예의 1924를(number) 보면 현재 보고있는 숫자가 다음숫자보다 작으면 삭제 할 수 있는 로직을 만들 수 있을것이다
  하지만 마지막을 보면 4177252841
  시작부터 4는 1보다 크니 유지가 될것이니 애매해질것같다. 

  이 로직을 조금 더 발전시키면 혹시 이전에 있는 값들이 
  순회를 하다가 더 큰값이 나오면 이전에 있는 값을 지우는 것 을 생각해볼 수 있다.

  큰 값이 나오면 이전값 중 더 작은값은 다 삭제한다. 라고 볼 수 있다.
  이 원리는 stack과 비슷하다
  결국 top에 해당하는 값보다 큰것이 들어오면 pop을 해주어야한다.
  즉, stack의 바닥에서부터 top은 큰 수부터 작은 수로 나열이 되어야 한다.


  1. stack 만들기
  const stack = [];

  2. counting해주기(몇개를 지웠는지)
  let count = 0;

  3. 입력받은 input string number를 loop를 돌면서 확인

    필요한 조건
    - count가  k보다 작아야한다 (count < k)
    - stack의 top에 해당하는 값보다 들어온 값이 큰 경우 pop (stack[stack.length - 1] < item)

    while (count < k && stack[stack.length - 1] < item) {
      stack.pop()
    }

  4. 반복하면서 이후 count를 1개 증가
     빠져나온 순간에는 top이 제일 숫자가 될것이다

     count += 1;

  5. 나머지는 item을 그대로 push 
      순차적으로 왼쪽에서부터 오른쪽 string은 큰 수에서 작은 수로 나열이 될것이다.

  console.log(stack.join(""))으로 찍어보게되면 
  94, 3234, 775841 잘 나오게 된다

  6. *** 한가지 케이스에서 실패릃 하는데 생각을 해보면
    이 count가 k까지 다 지워지지 않는 경우가 있을것이다
    큰 수 부터 나열이 되어서 예를 들어 "9876543" 이렇게 되어있으면 stack이 안지워질 수 있기 때문에
    예외 처리를 해준다

    계속 pop을 해주면 결국 마지막에 있는 값이 더 작을것이기 떄문에
    그대로 pop만 해주면 된다.

  while (count < k) {
    stack.pop();
    count += 1;
  }

  **** 
  일종의 그리디 문제라고 볼 수 있다.
  현재상황에서 제일 합리적인 판단을 하고
  그리디의 특징을 보면 선형시간에 처리가 된다.

  정확하게 하려면 모든 경우의 수를 구할 수 있지만 
  이 문제 같은 경우는 규칙이있어서 규칙을 이용해서 풀었다.

  * 그리디 문제의 특징 *
  입력값이 크고 직관적으로 풀 수 있다.
*/

function solution(number, k) {
  const stack = [];
  let count = 0;
  
  for (const item of number) {
      while (count < k && stack[stack.length - 1] < item) {
          stack.pop();
          count += 1;
      }
      stack.push(item);
  }
  
  while (count < k) {
      stack.pop();
      count += 1;
  }
  
  return stack.join("");
}
/* 1. 메모리 심화 */

/*
  * 변수를 선언할 때 자바스크립트 내부에서 어떤 일이 발생할까?

  let variable = 126;
  키워드 변수명 = 값

  이 코드가 실행될때 변수의 '고유 식별자' 를 생성하고 메모리에 주소를 '할당'한다.
  최종적으로 생성한 주소에 값을 넣는다.

  우리가 선언한 변수 / 상수는 값을 바라보는것이 아닌 
  메모리 주소를 바라보는 것이다

  * 새로운 변수에 기존 변수를 대입하면 어떻게 될까?

  let variable = 126;
  let variable2 = variable

  기존 변수의 '메모리 주소' 를 새로운 변수가 참조하는것이다

  * 기존 변수를 조작하면 어떻게 될까?

  let variable = 126;
  let variable2 = variable
  variable = variable + 1

  두 번째 생성한 변수의 값은 바뀌지 않는다.
  새로운 메모리 주소를 할당받고 그곳에 값을 넣는것이다.
  그 이유는 자바스크립트에서 '원시 타입' 은
  변경이 불가능하다.
  따라서 원시타입의 값이 바뀔때에는 항상 메모리가 '새로 할당' 된다.

  ** 자바스크립트 엔진

  자바스크립트 엔진은 가상 머신으로 구성되어있다
  Virtual Machine 이 머신에는 메모리 모델을 구현해놓았는데
  각각 'Heap', 'Call Stack' 영역으로 구성되어있따

  - Heap : 참조 타입이 들어간다
  - Call Stack : 원시 타입이 들어간다 

  * 방금 전 과정을 Call Stack으로 표현하면 스택처럼 쌓이게 된다 

  let a = 10;
  const b = 20;
  const arr = [];
  arr.push(5);
  arr.push(3);
  arr.push(1);

  이런 코드를 실행하게 되면

              arr = (0x008,0xFFB)
              b = (0x004, 20)
oxFFB, []     a = (0x004, 10)
  Heap    :    Call Stack

  먼저 순차적으로 콜 스택에 변수들이 쌓이게되고
  배열같은 경우 Object 타입이기 때문에 참조 타입으로 분류된다.
  배열을 선언하면 Heap에 배열 영역이 생성되는데
  Call Stack에 생성된 배열 변수는 Heap에서 생성된 배열의
  메모리 주소를 참조하게 된다.
  여기서 Haep 영역의 메모리는 '동적'으로 크기가 변할 수 있다

  따라서 0xFFB,[5, 3, 1]
  이렇게 배열에 값을 추가하면 Heap 영역에 그대로 할당이 된다.
  배열을 상수로 선언했는데 동작하는 이유이기도 하다.
  상수여도 push가 동작하는 이유는 Call Stack 에 할당된 메모리를
  변경하는 것이 아닌 Heap 메모리를 변경하는 것이기 때문이다.


  ** 사용을 마친 메모리는 어떻게 될까

  이전에 Garbage Collector를 통해 자바스크립트 엔진은 메모리를 정리한다고 했다.
  Garbage collector는 사용하지 않는 메모리를 해제하는 역할을 맡고 있다
  앞서 사용된 메모리 주소도 이로인해 정리 될 수 있다

  ** Mark and Sweep Algorithm
  닿을 수 없는 주소를 더 이상 필요 없는 주소로 정의하고 지우는 알고리즘

  현대적인 브라우저의 Garbage Collector Mark and Sweep Algorithm을
  통해 메모리를 정리한다. 브라우저에서 최상위 객체인 window로부터 시작하여
  닿을 수 없는 주소는 필요없다고 생각하여 지운다.


  * 만약 또 할당하면 어떻게 될까?

  let variable = 126;
  let variable2 = variable
  variable = variable + 1
  variable2 = variable + 1

  첫 번째 메모리값을 아무도 참조하지 않으면 어떻게 될까? (126)
  이 126에 해당하는 값은 Garbage Collector에 의해
  조용히 사라지게 된다.

  이처럼 메모리가 지워지는 것은 참조가 중요하다.
  ** 클로저가 가능한것도 참조 덕분이다.
*/
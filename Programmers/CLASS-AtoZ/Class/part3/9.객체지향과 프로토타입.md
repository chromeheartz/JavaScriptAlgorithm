### 📌 9. 객체지향과 프로토타입

**먼저 객체지향에서 객체란 무엇일까?**

현실의 버튼과 웹사이트 버튼을 떠올려보자. 현실의 버튼은
> 1. 누르면 뭔가 발생
2. 만질 수 있음
3. 튀어나옴
4. 고장날 수 있음
5. 색을 입힐 수 있음

이 중에서 웹사이트 버튼에 해당하는 것은 `1, 3, 5` 번일 것이다. 이처럼 **객체지향의 객체는 현실에 있는 것을 추상화한 것**을 말한다.

#### 그렇다면 여기서 추상이란 무엇일까?

이번엔 실제 지구, 지구본, 지구 지도를 떠올려보자. 우선 지구 지도의 경우에 위도와 경도를 정확하게 표현할 수 있지만 직사각형 모양으로 실제를 왜곡하게 된다. 그리고 지구본의 경우에는 지구 지도처럼 모든 나라를 한눈에 살펴보기는 어렵지만 실제 크기를 그대로 반영한다. 이처럼 **추상이란 사물이 지니고 있는 여러 측면 중에서 특정한 부분을 보는 것을 말한다** (그 외의 것들은 모두 버림)

### 📌 객체지향이란?

- 객체 위주로 설계하고 프로그래밍하는 패러다임
- 추상화의 `최소 단위` 는 객체
- 각각의 객체끼리 메세지를 주고 받으면 통신

> #### 객체지향에 대한 오해
- 객체지향은 패러다임일 뿐 언어와 상관 X (언어는 지향하는 것을 조금 더 편하게 구현할 수 있게 도와줄 뿐)
- 따라서 클래스가 없는 JS,Go,C언어에서도 객체지향 프로그래밍을 할 수 있음
- 자바스크립트는 `프로토타입` 을 통해 `객체지향 표현`
- 절차지향보다 객체지향이 더 좋은 것은 아님 (만들어야하는 `프로그램에 따라 적합한게 존재` -> 비교적 간단한 프로그램이라면 절차지향이 비교적 만들기 쉽고 `직관적`)

```js
function Person(name, company, move) {
  this.name = name;
  this.company = company;
  
  this.getName = function(){
    return this.name;
  };
  
  this.setName = function(name){
    this.name = name;
  };
}

const pham = new Person('팜윤태', '백수');
console.log(pham);

const kim = new Person('김영일', '백수');
console.log(kim);
```

#### 결과

```js
Person {
  name: '팜윤태',
  company: '백수',
  getName: [Function], // 메서드가 따로 정의
  setname: [Function] 
}
Person {
  name: '김영일',
  company: '백수',
  getName: [Function], // 메서드가 따로 정의
  setname: [Function] 
}
```

결과를 보면 `메서드가 따로 정의`되어 있음을 확인할 수 있다. (같은 내용임에도 생성된것이기 때문에 메모리 낭비)

프로토타입을 사용하면 이를 해결할 수 있는데 `기존의 객체를 복사하여 새로운 객체를 생성`하는 방식이다.

위의 코드를 다음과 같이 수정해보자.

```js
function Person(name, company, move) {
  this.name = name;
  this.company = company;
  
  Person.prototype.getName = function(){
    return this.name;
  };
  
  Person.prototype.setName = function(name){
    this.name = name;
  };
}

const pham = new Person('팜윤태', '백수');
console.log(pham);

const kim = new Person('김영일', '백수');
console.log(kim);

console.log(Person.constructor);
console.log(Person.__proto__);
console.log(pham.constructor);
console.log(pham.__proto__);
```

#### 결과

```js
Person {name: '팜윤태',company: '백수'}
Person {name: '김영일',company: '백수'}
[Function: Function]
[Function]
[Function: Person]
Person {getName: [Function], setName: [Function]}
```

이렇게 코드를 수정하면 `하위 객체`들은 `상위 객체`를 바라보게 됨. 객체들은 각자 `프로토`라는 객체를 내부적으로 가지게 되는데 이 내부에서 `상위의 객체를 링크`함. 이렇게 프로토타입을 사용하면 기존 객체를 효율적으로 사용 가능하다.

또한, `Object.create`를 이용하면 `기존 객체를 재활용`할 수 있다.

```js
const pham = {
  name: '팜윤태',
  getName: function () {
    return this.name;
  },
};

const kim = Object.create(pham); // kim은 pham을 복제 (kim의 상위객체는 pham)
kim.name = '김영일';

console.log(kim.getName()); // 김영일
console.log(pham.getName()); // 팜윤태
console.log(pham.__proto__); // {}
console.log(kim.__proto__); // {name: '팜윤태', getName: [Function: getName]}
```
### 📌 8. 함수형 프로그래밍

> **객체지향**
객체를 통해 데이터와 메소드를 놓고 객체간 통신함으로써 프로그램 작동
**함수형**
데이터를 함수를 이용해 새로운 데이터를 만들어나가는 데이터 파이프라인의 형태로 프로그램 작동

### 📌 함수형 패러다임

- 객체지향 추상화의 최소 단위가 객체인 것처럼 함수형은 함수가 `최소 단위`
- 함수 단위로 나눠지므로 `재사용성` 이 높음
- 불변성 지향함 -> 동작 예측 쉽고, `사이드 이펙트 방지` (쓰레드를 통한 동시성 문제도 해결된다는 의미)
- 객체지향은 `순차 => 분기 -> 반복 => 참조` 4가지 제어 흐름의 전환을 `객체를 통해 통제` 하고, 함수는 `변수 할당을 통해 4가지 제어 할당을 통제` 한다고 볼 수 있다.

### 📌 QUIZ

> N개의 숫자가 공백 없이 쓰여있다.
> 이 숫자를 모두 합해서 출력하는 프로그램을 작성하시오.
> ex) "12345" => 15

```js
// 객체지향 프로그래밍
function StringNumber(string) {
  this.string = string;
}
StringNumber.prototype.calculate = function () {
  const stringNumber = "12345";
  this.sum = 0;
  for (let i = 0; i < stringNumber.length; i += 1) {
    this.sum += stringNumber[i] - "0";
  }
};

const stringNumber = new StringNumber("12345");
const printer = new Printer();
stringNumber.calculate();
printer.log(stringNumber.sum);

// 절차지향 프로그래밍
const stringNumber = "12345";
let sum = 0;
for (let i = 0; i < stringNumber.length; i += 1) {
  sum += stringNumber[i] - "0";
}

// 함수형 프로그래밍
const stringNumber = "12345";
console.log(
  stringNumber
  	.split('')
  	.map(x => parseInt(x))
  	.reduce((x, y) => x + y, 0);
)
```

#### 객체지향 프로그래밍

- 숫자형태의 문자열을 담고 있는 `StringNumber` 객체가 있고 이 객체는 계산하여 `합` 을 구하는 역할.
- 계산한 값은 `객체에 저장`.
- 값을 `출력` 하는 일은 `Printer` 객체가 담당.
- 단순히 stringNumber 객체는 자신의 값을 Printer 객체로 넘기고 출력

#### 절차지향 프로그래밍

- 공유 데이터 변수인 `stringNumber / sum` 이 있다.
- 이를 반복문으로 통해 조작
- 간단한 문제에서는 절차지향이 더 편할 수 있다.

#### 함수형 프로그래밍

- 데이터를 모두 `함수 실행의 연속` 으로 만들어낸다.
- `문자열을 자른 함수 / 정수로 바꿔주는 함수 / 모든 요소를 합쳐주는 함수 / 출력 함수`
- 함수를 조합하여 결과를 도출한다.

### 📌 함수형 프로그래밍의 장점 (이자 단점)

- 상태가 없기 때문에 사이드 이펙트가 없다. `(변수 조작이 안됨)`
- 재사용성이 높다. (함수를 쪼개다가 많아지면 `오히려 복잡해짐`)
- 코드가 짧고 간결하다. (`많은 숙련도 요구`)


### 📌 선언형 프로그래밍

`객체지향` 과 `함수형` 처럼 설계에 대한 `패러다임` 이라기보단, `사고에 대한 패러다임` 으로 생각. 
기존 명령형 프로그래밍은 `문제를 어떻게 해결할지` 컴퓨터에 명령을 내리는 사고방식이라면 선언형 프로그래밍은 `무엇을 해결해야 할지` 에 집중한다. (컴퓨터에게 위임)

```js
// 명령형 예시
let a = [1,2,3,4,5];
for (let i =0; i<5; i++){
  if(a[i] % 2 === 0) {
    console.log(a[i]);
  }
}

// 선언형 예시
[1,2,3,4,5]
  .filter((i) => i % 2 === 0)
  .forEach((i) => console.log(i));
```

> #### 멀티 패러다임
굳이 패러다임을 나눌 필요는 없다. 각각의 장점을 극대화하기 위해서라면 둘 다 사용하는 것이 옳다.



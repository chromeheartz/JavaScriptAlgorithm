/* Ch19-1. 최소 신장 트리 */

/*
  최소한의 비용으로 모든 정점을 연결하려면?

  필요한 간선 외에는 전부 제거하면 된다.
  이런식으로 모두 연결되고 최소한의 비용으로 구성되어있는 그래프를
  '최소 신장 트리' 라고 부른다

  * 최소 신장 트리란? *

  - 신장 트리(Spanning tree)란 그래프 내에 '모든 정점을 포함' 하는 '최소 연결 부분' 그래프다.
  - 여기서 최소 신장 트리(MST)는 다음과 같은 조건을 만족한다.
    ㄴ 최소한의 간선으로 모든 정점이 연결되어야 한다.
    ㄴ 모든 신장 트리 중 가중치의 값이 최소여야 한다.
    ㄴ Cycle이 발생해서는 안된다.
  - 최소 신장 트리를 위한 알고리즘은 대표적으로 두가지가 있다
    ㄴ 크루스칼(Kruskal)
    ㄴ 프림 (Prim)

  * 미리 알아두는 크루스칼 알고리즘 *

  - 그리디 개념을 이용하여 구현할 수 있다
  - 먼저 모든 그래프를 부분집합으로 분리한다
  - 가장 가중치가 낮은 간선을 선택하고 부분 집합을 연결한다
  - 이 때, Cycle이 발생하지 않도록 주의
    ㄴ 공통 최상위 부모를 찾는것으로 막을 수 있다
    ㄴ Cycle을 판단하기 위한 알고리즘으로 Union-Find 알고리즘을 이용할 수 있다.

  * Unioin-Find 알고리즘 *

  - 서로소 집합을 구하기 위한 알고리즘
    ㄴ 서로소 집합은 '공통 원소가 없는 두 집합'을 표현하기 위한 자료구조
  - 서로 다른 두 집합을 병합하는 연산 'Union'과 집합의 원소가
    어떤 집합에 속해 있는지 판단하는 연산 'Find'를 나타낸다.
  - 보통 트리 구조로 구성한다
  - 편의상 재귀로 구현하는 경우가 많다.

  * Union *
  유니온연산은 두 원소를 하나의 집합으로 합쳐주는 작업을 한다.

  초기에는 자기 자신을 부모 정점으로 설정한다
  (자기 자신 = 자신이 속한 집합)

  키는 원소, 값은 자신이 속한 집합의 부모 정점

  A B C D E
  A B C D E

  - B가 A에 속할 경우
    B의 부모 원소를 바꿔준다. 이렇게 되면 두 원소는
    같은 집합이 된다

  A B C D E
  A A C D E

  - D가 B에 속할 경우
    D의 부모를 B의 부모인 A로 지정한다.
    즉, 집합의 최상위 원소를 부모로 지정
    D도 한 집합의 소속이 되었다.

  A B C D E
  A A C A E

  - E가 C에 속할 경우
    첫 사례와 같이 그대로 E의 부모가 C가 된다.

  A B C D E
  A A C A C

  - E가 B에도 속할 경우
    E의 부모를 그대로 B로 바꾸어주는것이 아닌
    C와 E가 속한 집합의 최상위 원소인 C의 부모를
    A, B, D가 속한 집합의 최상위 원소인 A로 지정한다

  A B C D E
  A A A A C

  이런식으로 두 집합을 하나의 집합으로 합쳐줄 수 있다
  결과를 보면 해당 구조만으로 각 원소가 어떤 집합에 속한지
  데이터만으로는 알 수 없기 때문에 Find 연산이 필요하다

  * Find *

  부모 원소가 자기 자신일때까지 올라가는것.
  예를 들어 E가 소속된 집합의 최상위 원소를 찾을 때
  C를 거쳐 A를 보면 최상위 원소를 알 수 있다.

  만약 다른 원소와 같은 집합인지 알고 싶다면
  두 원소의 최상위 원소가 같은지 보면 된다

  ** 만약 편향 트리라면 O(n) 이 소요된다.
  '경로 압축'을 통한 최적화가 가능하다.

  * 경로 압축 *

  최종 공통 분모를 찾을 때 결국 모든 경로를 탐색하게 되는데
  재귀로 구현했다면 돌아오면서 해당 원소의 부모 값을 최상위 부모로 바꾸어주면 된다.
  그렇게 하면 자연스럽게 경로가 최적화된다.

  *** Kruskal ***
  먼저 시작하기 전에 간선과 서로소 집합으로 구성한다

  Degrees
  A-B A-C A-D B-C C-F B-F D-E E-F F-G
   2   4   1   3   11   3  6   7   5

  Disjoint set
  A B C D E F G
  A B C D E F G

  * 탐욕적으로 탐색할것이기 때문에 간선들을 정렬해준다

  Sorted Degrees
  A-D A-B B-C B-F A-C F-G D-E E-F C-F
   1   2   3   3   4   5   6  7   11

  이렇게 구성하고나면 알고리즘이 시작된다.
  
  1. 먼저 가장 가중치가 낮은 간선을 선택하고 두 정점을 한 집합으로 이어준다

  Disjoint set
  A B C D E F G
  A B C *A* E F G

  2. 다음으로 가중치가 낮은 A-B간선을 선택하고 두 정점을 이어준다.
    그럼 A,B,D가 한 집합이 된다
  Disjoint set
  A B C D E F G
  A *A* C A E F G

  3. 마찬가지로 그 다음인 B-C간선을 선택하고 두 집합을 이어준다
     이번에도 B,F 간선을 선택하고 두 집합을 합쳐준다

  Disjoint set
  A B C D E F G
  A A *B* A E F G

  4. B-F 간선을 선택하고 두 집합을 합쳐준다

  Disjoint set
  A B C D E F G
  A A B A E *B* G

  5. A-C 간선으 선택하고 두 집합을 합쳐주려 하지만
     A와 C는 이미 같은 집합에 속해있다 (같은 집합을 연결하면 cycle이 발생한다)
     두 정점 집합의 최상위 원소가 같다면 이미 같은집합에 소속되어있다는 뜻이기 때문에
     cycle이 발생하여 해당 간선은 패스

  6. F-G는 cycle이 발생하지 않기 때문에 그대로 합쳐준다
  Disjoint set
  A B C D E F G
  A A B A E B *F*

  7. D-E간선을 선택. 
     여기까지오면 모든 정점이 한 집합으로 구성되어있다는것을 알 수 있다.

  Disjoint set
  A B C D E F G
  A A B A D B F

  8. 그 후 진행을 하면 계속 Cycle이 발생되니 패스한다.
  패스한 간선을 모두 제거하면 최소 신장 트리가 구성된다.

  Sorted Degrees
  A-D A-B B-C B-F F-G D-E
   1   2   3   3   5   6 

  ** 정리 **

  - 가장 가중치가 낮은 간선부터 선택하는 것 = Greedy
  - 각 원소가 같은 집합인지 확인하기 위한 알고리즘 = Union-Find
  - 두 정점이 같은 집합에 속한다면 = Cycle
*/
/* Ch18-1. 최단 경로 알고리즘 */

/*
  * 최단 경로 알고리즘 (Dijkstra) * 

  최단 경로 알고리즘 이란?

  - 그래프에서 특정 정점에서 목적지까지 최단 경로를 구하는 알고리즘
  - 이전에 배운 BFS, DFS도 최단 경로 알고리즘으로 사용할 수 있다.
  - 대표적인 최단 경로 알고리즘으로 다음과 같은 알고리즘이 있다.
    ㄴ BFS
    ㄴ 다익스트라 (Dijkstra)
    ㄴ 벨만-포드 (Bellman-Ford's)
    ㄴ 플로이드 와샬 (Floyd Warshall)
  - 목적에 따라 알고리즘을 선택할 수 있다.

  * BFS, DFS *
  그래프의 간선 가중치가 모두 같을 때 적합하다.
  예를 들어 2차원 배열(지도) 입력이 주어진 상태로
  최단거리를 찾아야 한다면 BFS, DFS로 푸는 경우가 많다.

  이 경우 배열에 한칸이 정점이 되고, 위 아래 오른쪽 왼쪽이 간선이 된다.
  간선의 가중치는 공평하게 1이 된다

  * 간선에 '가중치'가 있다면 => 다익스트라 알고리즘

  * Dijkstra *

  그래프의 간선 가중치가 각각 다른 경우 적합하다.

  다익스트라 알고리즘이란?

  - Edsger Wybe Dijkstra 가 고안한 최단 경로 알고리즘
  - 원래 발음은 데이크스트라에 가깝다고 한다.
  - 우선순위 큐를 이용하여 만들 수 있다.
  - 시간 복잡도는 V가 정점의 수, E가 간선의 수 일때 O(E log V)다.

  * 시각적인 예시 *

          1
     (2)/  |(1)  \(5)
     D     C       B
  (2)\  /(4) \(7) /(12)
      E   -(3)     F

  이런 구조가 있다고 가정

  1. 시작점을 제외한 나머지 정점의 거리는 무한(∞) 으로 초기화
     시작점의 거리는 0으로 설정
  A : B : C : D : E : F
  0 : ∞ : ∞ : ∞ : ∞ : ∞

  2. 시작점에서 갈 수 있는 정점을 찾는다
     각 정점의 가중치를 더해준다

  A : B : C : D : E : F
  0 : 5 : 1 : 2 : ∞ : ∞

  3. 이어서 설정한 정점중 최단거리가 짧은 정점을 선택
     C가 1로 가장 작기에 C가 선택된다.
     C에서 갈 수 있는 정점을 찾고 가중치를 더한다.
     갈 수 있는 정점은 E, F
     C까지의 거리인 1에서 각각 4, 7을 더해 E = 5, F = 8이 된다
  
  A : B : C : D : E : F
  0 : 5 : 1 : 2 : 5 : 8

  4. C는 방문처리하고 다음으로 작은 정점인 D가 선택
     D에서 갈 수 있는 정점은 E밖에 없다
     E는 이미 값을 가지고 있지만 D에서 가는 가중치의 합이
     더 적기 때문에 5에서 4로 갱신 된다

  A : B : C : D : E : F
  0 : 5 : 1 : 2 : 4 : 8

  5. D는 방문처리되고 그 다음 작은 정점인 E가 선택
     E에서 갈 수 있는 정점은 F밖에 없기에 F로 가는 거리를 계산
     계산 결과 가중치가 더 적기 때문에 기존값인 8을 7로 대체한다

  A : B : C : D : E : F
  0 : 5 : 1 : 2 : 4 : 7

  6. E는 방문처리하고 도착점인 F를 제외한 마지막 정점인 B를 선택
     B에서 갈 수 있는 정점은 F밖에 없는데 
     이 가중치의 값이 더 크기 떄문에 갱신하지 않는다

  A : B : C : D : E : F
  0 : 5 : 1 : 2 : 4 : 7

  7. 그럼 결과적으로 도착점인 F만 남는다
     F의 값을 확인해보면 가장 최단 경로가 7임을 알 수 있다.

  ** 다익스트라 알고리즘의 핵심은 '우선순위 큐' 이다 **
  가장 낮은 정점을 계속해서 선택해야한다.
  이를 효율적으로 구현하기 위해 Heap 을 사용할 수 있다

  *** 알고리즘 정리

  1. 시작점을 제외한 모든 정점의 거리를 무한으로 설정. 시작점은 0으로 설정
  2. 시작점을 선택
  3. 선택한 정점에서 갈 수 있는 정점의 거리를
     '정점(해당 정점까지의 최단 거리) 값 + 간선(거리) 값' 으로 갱신한다.
  4. 선택한 정점을 방문 처리한다.
  5. 이미 방문한 정점과 무한인 정점을 제외하고 '가장 최단 거리인 정점'을 선택한다.
  6. 더 이상 방문할 수 있는 정점이 없을 때 까지 3-5를 반복한다.
  7. 도착점의 값을 확인.
*/


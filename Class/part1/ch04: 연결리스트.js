/* Ch04. 연결리스트 */

/*
  * 연결 리스트 *
  연결 리스트는 각 요소를 포인터로 연결하여 관리하는 선형 자료구조다.
  각 요소는 노드라고 부르며 데이터 영역과 포인터 영역으로 구성된다.
  첫번째 노드를 헤드라고 부름.

  * 연결리스트의 특징
  - 메모리가 허용하는 한 요소를 제한없이 추가할 수 있다
  - 탐색은 O(n)이 소요된다
  - 요소를 추가하거나 제거할 때는 O(1) (상수시간)이 소요된다
    시간복잡도만 보아도 배열과는 정반대라는것을 알 수 있다
  - 단일(Singly Linked List), 이중 연결(Doubly Linked List), 선형 연결(Circular Linked List)가 존재한다

  * 추가와 삭제가 반복되는 로직이라면 *
  배열을 이용하면 시간복잡도가 너무 커지기 때문에 탐색에 유용하지만 추가 삭제에는
  적합하지않다

  ** 연결리스트의 핵심 로직 **
  요소 찾기, 요소 추가, 요소 삭제

  * 배열과의 차이점 *
  - 메모리 차이
    배열은 순차적인 데이터가 들어가기에 메모리를 연속적으로 사용하지만
    연결 리스트는 순차적이지 않기에데이터가 퍼져있다. 
    포인터를 사용하여 각 영역을 참조한다 (위치를 알기 위해)

  - 요소 추가 삭제
    배열에서 요소를 추가하거나 삭제하기 위해서는 O(n) (선형 시간)이 소요된다
    뒷요소를 앞에 당기거나 기존요소들을 뒤로 밀어야 하기 때문이다

    * 연결리스트 요소 삭제
    반면, 연결리스트 요소 삭제는 삭제할 요소를 고르고, 삭제할 요소의
    이전요소가 가르키는 포인터를 삭제할요소의 다음 노드에 연결하고, 
    삭제할 요소를 삭제하면 되기 때문에 O(1) (상수 시간)밖에 소요되지 않는다

    * 연결리스트 요소 추가
    추가할 요소를 사이에 끼워 넣기 위해 추가할 요소의 포인터를 끼워넣을 부분의
    다음 요소를 가리키게 하고 끼워넣을 요소의 전 요소의 포인터를 끼워넣을 요소를
    가리키게 한다

  * Singly Linked List 단일 연결 리스트 *
  가장 기본적이고 단순하다. Head 에서 Tail까지 '단방향'으로 이어지는 연결 리스트
  헤드 포인터가 있는데 Head를 가르키는 첫번째 출발점이라고 볼 수 있다
  Tail영역의 포인터는 Null이다. 갈곳이 없기 떄문에 연결리스트의 끝을 말한다

  - 요소 찾기
  헤드 포인터에서 시작하여 다음요소를 찾고 해당요소가 우리가 찾는 데이터인지 확인
  아니라면 다음요소로 넘어가면서 찾아내게 된다
  찾았다면 원하는 로직에 따라 결과를 반환하면 된다
  O(n) 소요

  - 요소 추가
  3을 중간에 추가한다면.
  첫번째로 추가할 요소의 포인터 영역을 다음 요소를 가르키게 만들고
  그 전 요소의 포인터가 추가할 요소를 가르키게 만든다
  단순한 로직이므로 O(1)시간이 소요. 
  만약 탐색해야한다면 탐색 로직이 실행되기 떄문에 O(n)이 소요된다
  그래서 추가를 위한 탐색을 하지 않도록 주의해서 코드 작성

  - 요소 삭제
  2를 삭제한다면
  삭제할 요소의 이전요소가 삭제할요소의 다음 요소를 가르키게 수정
  삭제할 요소를 메모리 상에서 지워준다
  O(1) 소요

  * Doubly Linked List 이중 연결 리스트 *
  단일과는 다르게 포인터가 2개 존재해서 양방향으로 이어지는 연결리스트
  단일 연결 리스트보다는 자료구조의 크기가 좀 크다

  - 요소 추가
  1,2,4,8 에서 3을 2와 4사이에추가한다고 생각
  추가할요소(3)의 다음노드를 추가할요소 다음요소(4)를 가리키게 만든다. 추가할요소 이전요소(2)의 다음 요소가
  추가할요소(3)을 가르키게 만든다. 이어서 추가할요소 다음요소(4)의 이전요소를 추가할요소(3)을 가르키게한다
  마지막으로 추가할요소(3)의 이전요소를 추가할요소의 이전요소(2)를 가르키게 만든다
  단일 연결리스트와 마찬가지로
  O(1) 상수시간만 소요

  - 요소 삭제
  1,2,4,8 에서 2를 삭제한다고 생각
  삭제할요소의 이전요소(1)의 다음요소가 삭제할요소의 다음요소(4)를 가르키도록 한다
  단일 이였다면 여기서 끝났겠지만 이중에서는
  삭제할요소의 다음요소(4)의 이전요소 가 삭제할요소의 이전요소(1)를 가르키도록 한 후
  삭제한 요소를 삭제한다
  O(1) 소요

  * Circular Linked List 선형 연결 리스트 *
  Singly 혹은 Doubly Linked List에서 Tail이 Head로 연결되는 리스트
  메모리를 아껴쓸 수 있으며, '원형 큐'등을 만들때에도 사용된다

  **** JavaScript의 단일 연결리스트 구현은 Logic/part1/singlyLinkedList.js ****

*/